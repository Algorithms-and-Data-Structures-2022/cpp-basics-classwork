#include <iostream>

int main() {  // область видимости функции

  // 1. Автоматическое управление памятью на стеке.

  // До этого момента мы работали с автоматическим выделением и освобождением памяти.
  // Автоматическое управление памятью производится в рамках областей видимости (scopes).

  {  // область видимости

    // Автоматически выделяется память под переменные.
    int var = 0;
    int arr[2] = {};

  }  // область видимости закрылась

  // Здесь, у нас уже нет переменной 'var' и массива 'arr'.
  // Участки памяти, выделенные под переменные, свободны и могут быть повторно использованы.

  {
      // Память выделяется из специального резервуара - стека.
      // Стек имеет довольно ограниченный размер - что будет, если раскомментировать код ниже?

      // int arr[1000000];
  }

  // 2. Ручное управление памятью на куче (heap).

  // Проблема нехватки памяти на стеке решается при помощи динамической памяти.
  // Динамическое выделение памяти - способ запроса памяти из ОС.
  // Память выделяется из объемного резервуара - кучи (heap).

  {
    // Запросим выделение памяти для хранения целочисленного типа int.
    // Оператор new возвращает указатель, который содержит адрес выделенной памяти.
    int *pointer = new int;  // по адресу хранится "мусор"

    *pointer = 1;  // устанавливаем значение участка памяти по указателю

    // При выходе из области видимости указатель автоматически "удалится" из памяти.
    // НО, участок памяти, на который ссылается указатель - НЕТ.

    delete pointer;     // вручную высвобождаем выделенную память
    pointer = nullptr;  // "обнуление указателя", является хорошей практикой

    // Рубрика "что будет, если":
    // - повторно высвободим участок памяти, на который ссылает pointer
    // - не обнулить указатель после высвобождения памяти
  }

  // 3. Утечка памяти.

  {
    // выделение памяти под int, инициализация значением 0, сохранение адреса в указатель
    int *pointer = new int{0};

    // ой, забыли высвободить память...
  }

  // Что произошло?
  // 1. Программа зарезервировала у ОС участок памяти и не высвободила его.
  // 2. ОС думает, что этот участок памяти занят и не трогает его.
  // 3. Участок памяти высвободится только при завершении программы.

  return 0;
}

/*
 * Задания:
 * 1. Что занимается автоматическим выделением памяти: ОС, компилятор?
 * 2. Чем страшна утечка памяти? Приведите примеры.
 * 3. Управляют ли вручную памятью в современном C++?
 */