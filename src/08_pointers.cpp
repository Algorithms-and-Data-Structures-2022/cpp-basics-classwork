#include <iostream>  // cout, printf

int main() {

  // 1. Память и адреса.

  // При инициализации переменной под нее автоматически выделяется
  // свободный участок памяти, размер которого зависит от типа переменной.
  // Например, под тип int выделится 4 или 8 байтов (зависит от компилятора).
  int a = 7;
  int b = 11;

  std::cout << "a = " << a << '\n';
  std::cout << "b = " << b << '\n';

  // 2. Понятие указателя.

  // В C++ мы можем получить адрес на участок памяти, в которой хранится переменная.
  // Для этого используется оператор взятие адреса & (амперсанд).
  int *pointer_to_a = &a;  // адрес в памяти, т.е. указатель на переменную типа int

  // Заметка 1: адрес переменной 'a' хранится в новой переменной под названием 'pointer_to_a'.

  /*
   * Пояснения:
   * 1. int * - читаем справа налево: указатель * на переменную типа int => * на int
   * 2. указатель - это переменная, которая хранит в себе адрес на определенный участок памяти
   * 3. адрес - это некое число (обычно представляемое в 16-ой СС)
   * 4. Тип указателя должен соответствовать типу переменной, на которую он указывает!
   */

  /*
   * Повторение - мать ... твою!
   * Под переменную выделяется участок памяти, у которой есть адрес (адрес = число).
   * Адрес переменной можно получить, используя оператор взятия адреса & (амперсанд).
   * Указатель - это новая переменная со значением адреса другой переменной.
   */

  // Выведем адрес переменных 'a' и 'b' в стандартный поток вывода stdout.
  printf("&a = %X\n", pointer_to_a);  // %X - вывода значения в 16-ой СС
  printf("&b = %X\n", &b);

  // 3. Чтение данных по указателю.

  // Замечательно, у нас есть адрес на участок памяти переменной 'a'.
  // Создадим новую переменную 'c' и скопируем туда значение переменной 'a'.
  // Для получения доступа к данным по указателю используется оператор разыменования * (звездочка).

  int c = *pointer_to_a;  // копируем в 'c' значение переменной, на которую ссылается указатель, т.е. 'a'

  /*
   * Пояснения (rolling in the deep ... shit):
   * 1. pointer_to_a - переменная, которая хранит в себе адрес 'a'
   * 2. адрес нам не нужен, мы хотим получить значение, которое хранится в 'a'
   * 3. используем оператор * для "перехода" по адресу 'a' (тук-тук, 'a', выходи)
   * 4. 'a' "вышел" и дал нам увидеть свое лицо (хранимое значение)
   * 5. сохраняем (копируем) значение 'a' в переменную 'c' оператором =
   */

  std::printf("c = %d\n", c);    // значение переменной равно значению 'a'
  std::printf("&c = %X\n", &c);  // адрес не совпадает с адресом 'a'

  // 4. Запись данных по указателю.

  // Изменим значение переменной 'a' по указателю.
  *pointer_to_a = 3;

  /*
   * Пояснения:
   * 1. pointer_to_a - переменная, которая хранит адрес 'a'
   * 2. при помощи оператора * "переходим" по адресу на участок памяти 'a'
   * 3. записываем в этот участок памяти новое значение оператором =
   */

  std::printf("a = %d\n", a);    // значение переменной изменилось
  std::printf("&a = %X\n", &a);  // адрес не изменился

  // 5. Указатель, который никуда не ссылается.

  // В С++ есть ключевое слово nullptr, которое обозначает, что указатель никуда не ссылается.
  int *null_pointer = nullptr;  // Python: None, Java: null

  // nullptr всегда ссылается на "несуществующий" участок в памяти, т.е. ноль
  std::printf("nullptr = %X\n", null_pointer);

  // 6. Проверка и сравнение указателей.

  // Проверка указателя на то, что он ссылается на "существующий" участок в памяти.

  if (!null_pointer) {
    std::cout << "Pointer is nullptr\n";
  }

  if (pointer_to_a) {
    std::cout << "Pointer 'a' is not nullptr\n";
  }

  // На один и тот же участок памяти можно создать несколько указателей.
  int* pointer_to_a_1 = &a;
  int* pointer_to_a_2 = &a;

  // Проверим, ссылаются ли они на один и тот же участок в памяти.
  if (pointer_to_a_1 == pointer_to_a_2) {
    std::cout << "pointers are equal\n";
  }

  return 0;
}