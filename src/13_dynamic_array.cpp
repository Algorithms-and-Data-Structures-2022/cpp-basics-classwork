#include <iostream>   // cout
#include <algorithm>  // copy

int main() {

  // 1. Динамический массив.

  // В отличие от статического массива, динамическое выделение памяти позволяет
  // устанавливать длину массива во время выполнения программы (runtime).

  {
    int length = 3;  // размер массива может быть получен из файла, сети и т.д.

    // Что здесь происходи?
    // 1. Выделяем участок памяти под массив размера length.
    // 2. Сохраняем адрес в указателе.
    int* arr = new int[length]{};  // все элементы нули

    // Доступ к элементам осуществляется через оператор [].
    arr[0] = 1;

    // высвобождаем выделенную память при помощи оператора delete[] (для массивов)
    delete[] arr;

    // выделили другой участок памяти размером 2 * length и сохранили адрес в указателе
    arr = new int[2 * length]{};

    delete[] arr;  // зачем мы еще раз высвобождаем память?
  }

  // Use-case: увеличение размера массива с копированием старых данных.
  {
    // исходный массив
    int* arr = new int[3]{0, 1, 2};  // [0, 1, 2]

    // расширенный массив, неинициализированный
    int* arr_resized = new int[5];  // [x, x, x, x, x]

    // копируем данные
    std::copy(arr, arr + 3, arr_resized);  // [0, 1, 2, x, x]

    // высвобождаем память, занимаемую исходным массивом
    delete[] arr;

    // указатель ссылаем на участок памяти расширенного массива
    arr = arr_resized;  // эквивалентно: arr = &arr_resized[0]

    for (int i = 0; i < 5; i++) {
      std::cout << arr[i] << ' ';
    }
    std::cout << '\n';

    // не забываем высвободить участок памяти, на который ссылается указатель
    delete[] arr;
  }

  return 0;
}