#include <iostream>   // cout, printf
#include <algorithm>  // fill, copy

int main() {

  // Массив - это тип данных, который хранит набор последовательных элементов одного типа.
  // Например, [5, 2, 7, 1, 9] - массив целых чисел.
  // Элементы массива индексируются с 0.

  // Статический массив - это массив фиксированного размера.
  // Пояснение: размер массива после его "объявления" нельзя изменить.

  // 1. Создание статического массива.

  // "объявление" массива
  int arr[3];  // тип данных (справа налево): массив [] из 3 элементов типа int

  // Заметка: "объявление" массива создает неинициализированный набор данных,
  // т.е. массив заполнен "мусором" (случайными значениями).

  // "объявление" и "инициализация" массива
  int arr_example_1[] = {3, 2, 1};  // вариант 1: без указания размера (размер вычисляется автоматически)
  int arr_example_2[3] = {3, 2, 1};  // вариант 2: с указанием размера
  int arr_example_3[3] = {};  // вариант 3: с указанием размера, инициализировать нулями

  // 2. Доступ к элементам статического массива.

  // Доступ к элементу массива осуществляется через оператор [] (квадратные скобки).

  // Запись данных по индексу элемента.
  arr[0] = 1;

  // Чтение данных по индексу элемента.
  int elem = arr[0];

  // 3. Массивы и циклы.

  // по индексу
  for (int i = 0; i < 3; i++) {
    if (arr[i] <= 0) {
      continue;  // "пропускаем" неположительные элементы массива
    }

    if (i == 1) {
      // "обрабатываем" элемент под индексом 1
    }

    arr[i] *= -1;  // ???
  }

  // for-each
  for (int e : arr) {
    // блок кода с обработкой элементов массива
  }

  // 4. Связь с указателями.

  int arr_example[] = {3, 2, 5};

  // C++ "гарантируется", что элементы массива находятся последовательно в памяти, т.е. они все соседи.
  // [1] [5] [9]  <-- соседние ячейки памяти (в скобках условный адрес в памяти)
  //  3   2   5   <-- значения, которые хранятся в ячейках памяти

  // указатель на ячейку номер 0: взятие адреса нулевого элемента
  int* arr_begin = &arr_example[0];

  std::printf("arr_example[0] = %d\n", *arr_begin);
  std::printf("&arr_example[0] = %X\n", arr_begin);

  // передвигаем адрес к следующей ячейке памяти (элементу массива)
  int* arr_next = arr_begin + 1;  // сдвиг значения адреса происходит на размер типа данных элемента массива

  std::printf("arr_example[1] = %d\n", *arr_next);
  std::printf("&arr_example[1] = %X\n", arr_next);

  // 5. Заполнение и копирование массивов.
  int arr_fill[5];  // массив из 5 элементов с "мусорными" значениями

  // заполняем массив значением 3 с 0ого элемента по 5ый (не включительно)
  std::fill(arr_fill, arr_fill + 5, 3);

  // копируем значение элементов массива в другой массив
  int arr_copy[5];

  // копируем значения из arr_fill (c 0 по 5ый элемент не включительно) в arr_copy
  std::copy(arr_fill, arr_fill + 5, arr_copy);

  return 0;
}

/*
 * Задания:
 * 1. Есть ли проблема определения размера массива?
 * 2. Как скопировать лишь часть массива?
 */